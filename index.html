<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Minecraft Mini – Level 3</title>
<style>
body{margin:0;overflow:hidden;background:#000}
#hud{
  position:fixed;top:10px;left:10px;
  color:#fff;font-family:monospace;
  background:rgba(0,0,0,.5);
  padding:6px;border-radius:6px
}
#inv{
  position:fixed;bottom:10px;left:50%;
  transform:translateX(-50%);
  display:flex;gap:6px
}
.slot{
  width:40px;height:40px;border:2px solid #777;
  background:#222;cursor:pointer
}
.slot.active{border-color:#fff}
</style>
</head>
<body>

<div id="hud">❤️ <span id="hp">100</span></div>
<div id="inv"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script>
/* ================== SCENE ================== */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87ceeb);

const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,5,5);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,.6));
const sun=new THREE.DirectionalLight(0xffffff,.6);
sun.position.set(50,100,50);
scene.add(sun);

/* ================== TEXTURES ================== */
const loader=new THREE.TextureLoader();
const TEX={
 grass: loader.load("https://i.imgur.com/6XbYH2E.png"),
 dirt:  loader.load("https://i.imgur.com/4Y6ZQxE.png"),
 stone: loader.load("https://i.imgur.com/V7aR0nY.png")
};
Object.values(TEX).forEach(t=>t.magFilter=THREE.NearestFilter);

/* ================== BLOCKS ================== */
const GEO=new THREE.BoxGeometry(1,1,1);
const BLOCK_MATS=[
  new THREE.MeshStandardMaterial({map:TEX.grass}),
  new THREE.MeshStandardMaterial({map:TEX.stone}),
  new THREE.MeshStandardMaterial({map:TEX.dirt})
];
let currentBlock=0;

/* ================== INVENTORY ================== */
const inv=document.getElementById("inv");
BLOCK_MATS.forEach((_,i)=>{
  const s=document.createElement("div");
  s.className="slot"+(i===0?" active":"");
  s.onclick=()=>select(i);
  inv.appendChild(s);
});
function select(i){
  currentBlock=i;
  document.querySelectorAll(".slot").forEach((s,j)=>{
    s.classList.toggle("active",i===j);
  });
}
addEventListener("keydown",e=>{
  if(e.key>="1"&&e.key<="3") select(+e.key-1);
});

/* ================== WORLD + SAVE ================== */
const blocks=[];
const worldData={};

function key(x,y,z){return x+","+y+","+z;}

function addBlock(x,y,z,type){
  const b=new THREE.Mesh(GEO,BLOCK_MATS[type]);
  b.position.set(x,y,z);
  b.userData={x,y,z,type};
  scene.add(b);
  blocks.push(b);
  worldData[key(x,y,z)]=type;
  saveWorld();
}

function removeBlock(b){
  const {x,y,z}=b.userData;
  delete worldData[key(x,y,z)];
  scene.remove(b);
  blocks.splice(blocks.indexOf(b),1);
  saveWorld();
}

/* ================== LOAD / SAVE (IndexedDB) ================== */
let db;
indexedDB.open("mc-mini",1).onsuccess=e=>{
  db=e.target.result;
  loadWorld();
};

function saveWorld(){
  if(!db) return;
  const tx=db.transaction("world","readwrite");
  tx.objectStore("world").put(worldData,"data");
}
indexedDB.open("mc-mini",1).onupgradeneeded=e=>{
  const d=e.target.result;
  d.createObjectStore("world");
};

function loadWorld(){
  const tx=db.transaction("world");
  const req=tx.objectStore("world").get("data");
  req.onsuccess=()=>{
    if(!req.result) generateGround();
    else{
      for(const k in req.result){
        const [x,y,z]=k.split(",").map(Number);
        addBlock(x,y,z,req.result[k]);
      }
    }
  };
}

/* ================== GROUND ================== */
function generateGround(){
  for(let x=-10;x<=10;x++)
    for(let z=-10;z<=10;z++)
      addBlock(x,0,z,0);
}

/* ================== COLLISION ================== */
function solidAt(x,y,z){
  return blocks.some(b=>
    Math.abs(b.position.x-x)<0.5 &&
    Math.abs(b.position.y-y)<0.5 &&
    Math.abs(b.position.z-z)<0.5
  );
}

/* ================== PLAYER ================== */
let velY=0,onGround=false;
let hp=100;
const hpEl=document.getElementById("hp");

const keys={};
addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

let yaw=0,pitch=0;
addEventListener("mousemove",e=>{
  if(document.pointerLockElement){
    yaw-=e.movementX*0.002;
    pitch-=e.movementY*0.002;
    pitch=Math.max(-1.5,Math.min(1.5,pitch));
  }
});
addEventListener("click",()=>document.body.requestPointerLock());

/* ================== RAYCAST ================== */
const ray=new THREE.Raycaster();
const mouse=new THREE.Vector2(0,0);

addEventListener("mousedown",e=>{
  ray.setFromCamera(mouse,camera);
  const hit=ray.intersectObjects(blocks);
  if(!hit.length) return;

  if(e.button===0) removeBlock(hit[0].object);
  if(e.button===2){
    const p=hit[0].object.position;
    const n=hit[0].face.normal;
    addBlock(p.x+n.x,p.y+n.y,p.z+n.z,currentBlock);
  }
});
addEventListener("contextmenu",e=>e.preventDefault());

/* ================== MOB ================== */
const mob=new THREE.Mesh(
  new THREE.BoxGeometry(1,2,1),
  new THREE.MeshStandardMaterial({color:0xff4444})
);
mob.position.set(4,1,4);
scene.add(mob);
let mobDir=1;

/* ================== LOOP ================== */
function loop(){
  requestAnimationFrame(loop);

  camera.rotation.order="YXZ";
  camera.rotation.y=yaw;
  camera.rotation.x=pitch;

  const speed=0.15;
  let nx=camera.position.x;
  let nz=camera.position.z;

  if(keys.w) nz-=speed;
  if(keys.s) nz+=speed;
  if(keys.a) nx-=speed;
  if(keys.d) nx+=speed;

  if(!solidAt(nx, camera.position.y-1, camera.position.z))
    camera.position.x=nx;
  if(!solidAt(camera.position.x, camera.position.y-1, nz))
    camera.position.z=nz;

  velY-=0.01;
  let ny=camera.position.y+velY;
  if(solidAt(camera.position.x,ny-1,camera.position.z)){
    velY=0;onGround=true;
  }else camera.position.y=ny;

  if(keys[" "]&&onGround){
    velY=0.25;onGround=false;
  }

  // mob AI + damage
  mob.position.x+=0.03*mobDir;
  if(Math.abs(mob.position.x-camera.position.x)<1.2 &&
     Math.abs(mob.position.z-camera.position.z)<1.2){
    hp=Math.max(0,hp-0.2);
    hpEl.textContent=Math.floor(hp);
  }
  if(Math.abs(mob.position.x-camera.position.x)>6) mobDir*=-1;

  renderer.render(scene,camera);
}
loop();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
